# 高级数据

#### 索引

几乎所有的索引都是建立在字段之上的。

系统根据某种算法，将已有的数据（未来可能新增的数据），单独建立一个文件：文件能够实现快速的匹配数据，并且能够快速找到对应表中的记录。

索引的意义

1. 提升数据查询效率
2. 约束数据的有消息（唯一性）

增加索引：索引本身会产生索引文件，有时候比数据文件还大，会耗费磁盘空间。

如果某个字段需要作为查询的条件经常使用。可以使用索引。

如果某个字段需要保证数据的唯一性。可以使用索引。

1. 主键索引 primary key
2. 唯一索引 unique key
3. 全文索引 fulltext index
4. 普通索引 index

全文索引：针对文章的内部的关键字进行索引。最大的问题是如何确认关键字。

### 关系

将实体与实体之间的关系反应到数据库设计上来。

一对一，一对多，多对多。

所有的关系都是指表与表之间的。

#### 一对一

一张表中的一条记录只能与另一张表的一条记录匹配。

| id(pri) | 姓名   | 身高   | 体重   | 住址   | 身份证号 | 联系人  | 婚否   | 性别   |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|         |      |      |      |      |      |      |      |      |

为了把不常用的信息和常用的信息分离。需要建立两张表。这两张表是一对一关系。

| id(pri) | 姓名   | 性别   | 身份证号 | 住址   |
| ------- | ---- | ---- | ---- | ---- |
|         |      |      |      |      |

| id(pri) | 身高   | 体重   | 联系人  | 婚否   |
| ------- | ---- | ---- | ---- | ---- |
|         |      |      |      |      |

这样就将常用信息和不常用信息进行了分离。提高了查询的效率。

#### 一对多。

一张表A中的一条记录对应另一张表B中的多条记录。而表B中的一条记录对应该表A中的一条记录。

妈妈表

| id(pri) | 姓名   | 年龄   |
| ------- | ---- | ---- |
|         |      |      |

孩子表

| id(pri) | 姓名   | 年龄   | 性别   | 妈妈ID（妈妈表主键） |
| ------- | ---- | ---- | ---- | ----------- |
|         |      |      |      |             |

一个妈妈可能有多个孩子。一个孩子只有一个妈妈。

为了让两张表产生联系。需要在孩子表中添加一个字段。用于和妈妈表建立联系。（因为一个孩子只能有一个妈妈）。

#### 多对多

A表中的一条记录对应B表中的多条记录。B表中的一条记录对应A表中的多条记录。

老师教学：老师和学生。

老师表

| T_ID | 姓名   |
| ---- | ---- |
|      |      |

学生表

| S_ID | 姓名   |
| ---- | ---- |
|      |      |

一个老师教过很多学生。一个学生有很多教师。

解决方案。不能再学生表中添加老师或在老师表中添加学生。

新建一张表（中间关系表）维护老师和学生之间的关系。

| T_ID | S_ID |
| ---- | ---- |
|      |      |

教师表与中间表是一对多。学生表与中间表也是一对多。

学生找老师：找出学生id—>中间表多条记录— >老师表匹配（一条）

老师找学生：找出老师id—>中间表多条记录—>学生表匹配（一条）

### 范式

范式是离散数学中的一种知识。是为了解决数据存储与优化的问题。保存数据的存储之后凡是能够通过关系寻找出来的数据，坚决不再重复存储。终极目标是为了解决数据的冗余。



范式是一种分层结构，分为6层。每一层都比上一层更加严格。

若要满足某一层范式，必须先满足上一层范式。

1nf，2nf，…6nf

在设计数据库的时候，会用到范式来指导数据库的设计。数据库既要保证存储空间又要保证效率。不能完全按照范式要求来。范式具有指导意义，但不是强制。

#### 1nf

第一范式

在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来用之前还需要额外的处理（拆分）。

那么表的设计不符合第一范式。 即字段要具有原子性。

#### 2nf

在数据表设计的过程中，如果有复合主键。且表中有字段不是由整个主键来确定，而是依赖主键中的某一个字段，

即存在部分依赖问题。第二范式就是要解决表的设计不能出现部分依赖。

当出现这种情况时，可以有两种解决方案，

方案一、将表拆分成几个表。以满足条件。

方案二、取消复合主键，设置逻辑主键id。

方案三、取消复合主键，设置唯一键。

#### 3nf

 一个表中的所有字段都应该直接依赖主键。如果有一个字段先依赖一个非主键字段，再最终实现主键依赖。那么这种依赖叫做传递依赖。第三范式就是要解决传递依赖的问题。

解决方案：将所有存在传递依赖的字段拆分，新建一个表。

#### 逆规范化

有时候在设计表的时候，如果一张表的有几个字段需要从其他表获取信息。这样理论上可以获取信息。但是效率比较低。此时会采取不保存主键，直接保存数据的做法。在查询的时候，一张表可以直接提供数据，不使用多表查询。